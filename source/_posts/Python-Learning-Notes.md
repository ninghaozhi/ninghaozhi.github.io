---
title: python学习笔记
---

## 引言

这不是我第一次学习编程。在此之前我学习过 c 语言,前端，然后就是现在的 py。我为什么要学这些东西？我一个非科班的大学生。应该是兴趣占很大一部分，然后是我有想实现的东西，为此我拿出时间来尝试，自学的问题是常找不到学习方向，也看不清自己究竟处在什么位置。但路就在那。

---

## 编程规范

### 注释

单行注释用#开头。多行注释用三个双引号包裹

```python
# 这一行被注释了
"""
这一大段内容都被注释了
这一大段内容都被注释了
这一大段内容都被注释了
"""
```

## 输入输出

### 输入

input()函数受一个标准输入数据，执行之后会阻塞等待人从现实世界输入内容，回车之后再继续运行。这里输入的是一个字符串，根据需要进行类型转换。

```python
>>> a = input("请输入一个内容：")
请输入一个内容: 123  # 输入整数
>>> type(a) # 查看数据类型
<class 'str'>  # 字符串
```

![](/images/shuru.png)

### 输出

print() 方法用于打印输出。可以打印多个对象，打印多个对象时用分割符连接。

```python
print(*objects, sep=' ', end='\n', file=sys.stdout)
# sep=' '用来间隔多个对象，默认值是一个空格。是在这一个print里间隔。多个对象用','隔开，这个不会打印出来的，会显示一个空格
# end -- 用来设定以什么结尾。默认值是换行符 \n，我们可以换成其他字符串。
print("",end=" "，sep="") # 效果是打印一个空格，并且多次输出不会换行。原理是打印一个空字符串，把默认的'\n'变成空格,然后因为只有一个对象，所以sep=""没有作用。
print(" ",end=""，sep="") # 效果跟上面一样。原理打印一个空格，把'\n'替换掉，用空（啥都没有）替换的。
```

### 变量

程序就是用来处理数据的，而变量就是用来存储数据的

- 在 Python 中，每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建
- 等号（=）用来给变量赋值
  - = 左边是一个变量名
  - = 右边是存储在变量中的值
- 变量名第一次出现是定义变量
- 变量名再次出现，不是定义变量，而是直接使用之前定义过的变量

```python
变量名 = 值
```

## 数值类型

### int（整形）

整形，也被称之为整数，整数就是数学中的数字。整形在 Python 中不受长度限制大小范围，可以定义任意大的数字（有些语言不行）
使用 type 函数可以查看一个变量的类型

```python
>>> 1
1
>>> type(1)
<class 'int'>
```


### float（浮点型）

浮点型也就是小数，与数学中的小数保持一致。

```python
>>> 1.0
1.0
>>> type(1.0)
<class 'float'>
```

运算、运算符优先级与整形是一样。

### 类型转化

浮点数转化为整形（显示转化）

```python
>>> int(1.0)
1
>>> float(1)
1.0
```

隐式转化，系统背后默认进行转换。

- 在 Python 中，除法运算符 / 总是返回浮点数（float）
- 即使操作数是整数，结果也会被隐式转换为浮点数

```python
>>> 1 / 2
0.5
>>> type(2 / 1)
<class 'float'>
```

**1. 数值运算中的自动提升**

```Python
# 整数 → 浮点数
result = 3 + 4.5  # int 3 自动转为 float 3.0

# 整数/浮点数 → 复数
result = 2 + 3j  # int 2 自动转为 complex(2,0)
```

**2. 布尔上下文中的转换**

```Python
# 非布尔值 → 布尔值
if "hello":   # 字符串 → True
if 0:         # 整数0 → False
if []:        # 空列表 → False
```

**3. 比较运算中的转换**

```Python
# 跨类型比较
print(10 == 10.0)  # True，整数转浮点数比较
print(True == 1)   # True，布尔转整数
```

**4. 字符串格式化中的转换**

```Python
# 自动转为字符串
message = f"Value: {42}"  # int 42 → str "42"
```

## 算数运算符

因为是整数，所以也可以进行数学中的基本运算。使用算术运算符号，用来处理四则运算。计算优先级跟数学一样，指数>乘除>加减，同级运算从左到右。()可以调整优先级

| 运算符 | 描述   | 实例                                      |
| :----: | ------ | ----------------------------------------- |
|   +    | 加     | 10 + 20 = 30                              |
|   -    | 减     | 10 - 20 = 10                              |
|   \_   | 乘     | 10 \_ 20 = 200                            |
|   /    | 除     | 10 / 20 = 0.5                             |
|   //   | 取整除 | 返回除法的整数部分（商）9 // 2 输出结果 4 |
|   %    | 取余数 | 返回除法的余数 9 % 2 = 1                  |
|  \*\*  | 幂     | 又称次方、乘方，2 \*\* 3 = 8              |

除此之外，+ 还可以作为字符串（包括后续要介绍的序列）的连接运算符。

```python
>>> s1 = 'Hello '
>>> s2 = '正心'
>>> # 使用 + 连接两个字符串
>>> print(s1 + s2)
Hello 正心
```

## 字符串

字符串是 Python 中最常用的数据类型。我们可以使用单引号（'）或双引号（"）来创建字符串。单双引号总体来说没有任何区别，只在单引号当普通字符时容易区分：如 var = "let's go"

### format

基本语法是使用 {} 和 .format()。format 函数可以接受不限各参数，位置可以不按照顺序

```python
name = '张三'
age = 18
nickname = '法外狂徒'

# format 用 {} 占位
print('姓名：{name}，年龄{age}，外号：{nickname} '.format(nickname = '法外狂徒', age = 18,nickname = '法外狂徒' ))# 关键字参数命名
# 输出：姓名：张三，年龄18，外号：法外狂徒
print('hello {1} 你今年已经{0}岁了'.format(age，name))# 位置参数索引
# 输出：hello 张三 你今年已经18岁了
print('姓名：{}，年龄{}，外号：{} '.format(name, age, nickname))
# 输出：姓名：张三，年龄18，外号：法外狂徒
```

### f

f'{}'形式，并不是真正的字符串常量，而是一个运算求值表达式，可以很方便的用于字符串拼接、路径拼接等

```python
name = '张三'

# f 在字符串中嵌入变量
print(f'hello {name} !')
```

### %s

% 被称为格式化操作符，专门用于处理字符串中的格式

- 包含 % 的字符串，被称为格式化字符串
- % 和不同的字符连用，不同类型的数据需要使用不同的格式化字符

| 格式化字符 | 含义                                                                 |
| :--------: | -------------------------------------------------------------------- |
|     %s     | 字符串                                                               |
|     %d     | 有符号十进制整数，%06d 表示输出的整数显示位数，不足的地方使用 0 补全 |
|     %f     | 浮点数，%.2f 表示小数点后只显示两位                                  |
|     %%     | 输出 %                                                               |
|     %c     | %ASCII 字符                                                          |
|     %o     | %8 进制                                                              |
|     %x     | %16 进制                                                             |
|     %e     | %科学计数法                                                          |

格式如下：

```python
print("格式化字符串 %s" % '变量 1')
print("格式化字符串" % ('变量 1', '变量 2', ...))
```

```python
name = '张三'
age = 18
nickname = '法外狂徒'

name2 = '李四'
age2 = 19
nickname2 = '帮凶'

# %s 用 %s 占位
print('姓名：%s' % name)
# 多个参数
print('%s，%s 哦嗨呦' % (name, name2))
```

## 查找和替换

| 方法                             | 用法                                                  |
| :------------------------------- | :---------------------------------------------------- |
| string.strip()                   | 默认去掉 string 左右两边的空白字符                    |
| string.replace(old_str, new_str) | 把 string 中的 old_str 替换成 new_str                 |
| string.split()                   | 默认以空白字符进行分割                                |
| string.join(seq)                 | 将 seq 中所有的元素（字符串类型）合并为一个新的字符串 |

## 案例

| 输入                                 | 输出                       |
| ------------------------------------ | -------------------------- |
| 'hello zhengxin !'.split()           | ['hello', 'zhengxin', '!'] |
| 'hello zhengxin !'.split('z')        | ['hello ', 'hengxin !']    |
| 'hello zhengxin !'.strpi()           | hello zhengxin !           |
| 'hello zhengxin !'.replace(' ', '#') | 'hello#zhengxin#!'         |
| ' '.join(['hello', 'zhengxin', '!']) | 'hello zhengxin !'         |
| ','.join(['hello', 'zhengxin', '!']) | 'hello,zhengxin,!'         |

## 转义字符

| 转义字符 | 描述              |
| -------- | ----------------- |
| \        | (在行尾时) 续行符 |
| \\       | 反斜杠符号        |
| \'       | 单引号            |
| \"       | 双引号            |
| \n       | 换行              |
| \t       | 横向制表符        |
| \r       | 回车              |

## 布尔值

bool 类型只有两种状态真或假
python 中布尔值使用常量 True 和 False 来表示；注意大小写

```python
>>> bool(None)
False
>>> bool("")
False
>>> bool(" ")
True
>>> def a():
...     pass
...
>>> bool(a)
True
```

```
bool 是 int 的子类（继承 int ），故 True == 1 False == 0 是会返回 Ture
```

True 是对， False 是错

- 布尔类型只有两种状态，True or Flase
- 数字除了零之外，其余均为 True
- 字符串除了空字符串之外都为 True
- 对象除了空对象之外，其余均为 True

默认情况下，所有类型都可以转化为布尔类型

## 赋值运算符

| 运算符 | 描述             | 实例                                  |
| ------ | ---------------- | ------------------------------------- |
| =      | 简单的赋值运算符 | c = a + b 将 a + b 的运算结果赋值为 c |
| +=     | 加法赋值运算符   | c += a 等效于 c = c + a               |
| -=     | 减法赋值运算符   | c -= a 等效于 c = c - a               |
| \*=    | 乘法赋值运算符   | c _= a 等效于 c = c _ a               |
| /=     | 除法赋值运算符   | c /= a 等效于 c = c / a               |
| %=     | 取模赋值运算符   | c %= a 等效于 c = c % a               |
| \*\*=  | 幂赋值运算符     | c **= a 等效于 c = c ** a             |
| //=    | 取整除赋值运算符 | c //= a 等效于 c = c // a             |

## 比较运算符

| 运算符 | 功能                                                                          |
| :----: | ----------------------------------------------------------------------------- |
|   >    | 大于，如果运算符前面的值大于后面的值，则返回 True；否则返回 False             |
|   >=   | 大于或等于，如果运算符前面的值大于或等于后面的值，则返回 True；否则返回 False |
|   <    | 小于，如果运算符前面的值小于后面的值，则返回 True；否则返回 False             |
|   <=   | 小于或等于，如果运算符前面的值小于或等于后面的值，则返回 True；否则返回 False |
|   ==   | 等于，如果运算符前面的值等于后面的值，则返回 True；否则返回 False             |
|   !=   | 不等于，如果运算符前面的值不等于后面的值，则返回 True；否则返回 False         |

## 逻辑运算符

Python 语言支持逻辑运算符，以下假设变量 a 为 10, b 为 20:

| 运算符 | 逻辑表达式 | 描述                                              | 实例 |
| :----: | :--------: | ------------------------------------------------- | ---- |
|  and   |  x and y   | 布尔"与" ，两个条件都满足 (a and b) 返回 20。     |
|   or   |   x or y   | 布尔"或"，两个条件中满足一个 (a or b) 返回 10。   |
|  not   |   not x    | 布尔"非" ，否定之前的结果 not(a and b) 返回 False |

- and 布尔逻辑：当 x 和 y 都为真时返回 True，否则返回 False
- and 实际行为：返回第一个为假的值，或者最后一个值（如果所有值都为真）
  <br/>
- or 布尔逻辑：当 x 和 y 都为真时返回 True，否则返回 False
- or 实际行为：返回第一个为假的值，或者最后一个值（如果所有值都为真）
  <br/>
- not 就是反着来

## 成员运算符

成员运算符用于 测试 序列中是否包含指定的 成员

| 运算符 | 描述                                                  | 实例                        |
| ------ | ----------------------------------------------------- | --------------------------- |
| in     | 如果在指定的序列中找到值返回 True，否则返回 False     | '3' in '123' 返回 True      |
| not in | 如果在指定的序列中没有找到值返回 True，否则返回 False | '3' not in '123' 返回 False |

## 身份运算符

is 比较的是 两个实例对象是不是完全相同，它们是不是同一个对象，占用的内存地址是否相同 。莱布尼茨说过：“世界上没有两片完全相同的叶子”，这个 is 正是这样的比较，比较是不是同一片叶子（即比较的 id 是否相同，这 id 类似于人的身份证标识）。
身份运算符用于比较两个对象的存储单元
|运算符 |描述 |实例|
|---|---|---|
|is |is 是判断两个标识符是不是引用自一个对象 |x is y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False

## 运算符优先级

|           运算符            | 描述                 |
| :-------------------------: | -------------------- |
|            \*\*             | 指数 (最高优先级)    |
|          \* / % //          | 乘，除，取模和取整除 |
|            & 位             | 'AND'                |
|          <= < > >=          | 比较运算符           |
|          <> == !=           | 等于运算符           |
| = %= /= //= -= += \*= \*\*= | 赋值运算符           |
|          is is not          | 身份运算符           |
|          in not in          | 成员运算符           |
|         not and or          | 逻辑运算符           |

## if 判断语句

判断的定义

- 如果条件满足，才能做某件事情，
- 如果条件不满足，就做另外一件事情，或者什么也不做
  语法

1. 冒号和缩进是一种语法，一个 tab 键相当于四个空格，然而在 if 条件语句满足条件下，后面的英文冒号后，直接 enter 键，会自动缩进，不需要手动缩进。
2. 赋值满足条件，则 print 执行下一步
3. 赋值不满足条件，则跳过，如果只有一条，则输出内容无；如果有 2 条，则跳过第一条，执行第二条，即 else

if...else... 语句，当 if 的条件为 True 时执行 if 下的语句块，否则执行 else 下语句块

```python
if '要判断的条件':
    ...  # 伪代码，表示省略其他的内容
    # '条件成立时，要做的事情'
else:
    ...
    # '条件不成立时，要做的事情'
```

elif 多条件判断语句，相当于在 if 判断时多了种判断条件。这样就是 if elif 处理条件成立的情况，else 处理条件都不成立的情况

```python
if '条件 1':
    ...  # '条件 1 满足执行的代码'
elif '条件 2':
    ...  # 条件 2 满足时，执行的代码
elif '条件 3':
    ...  # 条件 3 满足时，执行的代码
else:
    ...  # 以上条件都不满足时，执行的代码
```

if 的嵌套

- 在开发中，使用 if 进行条件判断，如果希望在条件成立的执行语句中再增加条件判断，就可以使用 if 的嵌套
- if 的嵌套的应用场景就是：在之前条件满足的前提下，再增加额外的判断
- if 的嵌套的语法格式，除了缩进之外和之前的没有区别
  就像是剥洋葱一层一层的，递进式的去思考，把具体的事情抽象出来，剥出来在包回去。

三元表达式

```python
a = input("请输入 a：")
b = input("请输入 b：")
max_number = 0

if a > b:
    max_number = a
else:
    max_number = b

print(max_number)
```

```python
a = input("请输入 a：")
b = input("请输入 b：")
max_number = a if a > b else b
print(max_number)
```

## while 循环

当满足条件时进入循环，进入循环后，当条件不满足时，跳出循环。while 语句的一般表达式为：while（表达式）{循环体}。

案例
需求 —— 打印 5 遍 我喜欢 Python

```python
# while 循环
i = 0  # 限制条件
while i < 5:  # 循环申明 判断条件
    print('我喜欢 Python !')  # 程序执行的内容
    i += 1  # 限制条件
```

死循环
由于程序员的原因，忘记在循环内部修改循环的判断条件，导致循环持续执行，程序无法终止！

```python
i = 0
while i < 5:
    print('我喜欢 Python !')
    # i += 1  # 忘记给限制条件就会造成死循环
```

## for 遍历

在计算机科学里，遍历的一种，指的是按照某种规则，不重复地访问某个对象的所有内容的过程。

```python
>>> for item in 'hello world !':
...     print(item)
...
h
e
l
l
o

w
o
r
l
d

!
```

for 比较常用的方式是与 range 搭配使用，例如：

```python
>>> for i in range(5):
...     print(i)
...
0
1
2
3
4
>>>s
```

## range

range() 函数可创建一个整数列表，一般用在 for 循环中。
语法

```python
range(start, stop[, step])
```

- start: 计数从 start 开始。默认是从 0 开始。例如 range(5)等价于 range(0, 5);
- stop: 计数到 stop 结束，但不包括 stop。例如：range(0, 5) 是 [0, 1, 2, 3, 4] 没有 5
- step：步长，默认为 1。例如：range(0, 5) 等价于 range(0, 5, 1)

起始值与结束值

```python
>>> list(range(5))
[0, 1, 2, 3, 4]
>>> list(range(0, 5))
[0, 1, 2, 3, 4]
>>> list(range(1, 6))
[1, 2, 3, 4, 5]
```

步长

```python
>>> list(range(0, 5))
[0, 1, 2, 3, 4]
>>> list(range(0, 5, 1))
[0, 1, 2, 3, 4]
>>> list(range(0, 5, 2))
[0, 2, 4]
```

## for 遍历可迭代对象

for 可以迭代所有可迭代对象（字符串、列表、元组、集合、字典）

```python
for num in list(range(1000)):
    print(num)
```

## 中断语句

break 和 continue 是专门在循环中使用的关键字

- break 某一条件满足时，退出循环，不再执行后续重复的代码
- continue 某一条件满足时，不执行后续重复的代码
  break 和 continue 只针对当前所在循环有效

**break**
从内部中断循环，在循环过程中，如果 某一个条件满足后，不再希望 循环继续执行，可以使用 break 退出循环

案例：登录账号
循环一直输入账号密码，输入成功之后跳出循环

```python
while True:

    password = input("请输入密码")
    if password == '123456':
        # 当满足条件时 中断循环
        print('密码输入正确，跳出循环')
        break

    # 重复执行的代码
    print("输入的密码错误，请重新输入")
```

**continue**
中断本次循环的后面部分
在循环过程中，如果某一个条件满足后，不希望执行循环代码，但是又不希望退出循环，可以使用 continue
也就是在整个循环中，只有某些条件，不需要执行循环代码，而其他条件都需要执行

```python
while True:

    password = input("请输入密码")
    if password == '123456':
        # 当满足条件时 终止后续的操作
        print('密码输入正确，终止后续的操作，重新进入循环')
        continue

    print("输入的密码错误，请重新输入")
```

else 可以在 while 和 for 循环中运用，else 和 while 或 for 搭配使用，不再是条件判断的含义。而是与 while 与 for 组成了一个新的语句。正常结束就执行，不正常就是就不执行。

- 循环被 break 中断 使用 break 语句提前退出循环 ❌ 不执行
- 循环因异常终止 循环体中出现未处理的异常 ❌ 不执行
- 函数返回中断 在循环中使用 return 退出函数 ❌ 不执行

## list（列表）

定义：列表是一种可变的、有序的数据结构，可以随时添加和删除其中的元素。

列表非常适合利用顺序和位置定位某一元素，尤其是当元素的顺序或内容经常发生改变时。与字符串不同，列表是可变的。可以直接对原始列表进行修改：添加新元素、删除或覆盖已有元素。

## 创建列表

- list（列表）是 Python 中使用最频繁的数据类型，在其他语言中通常叫做数组
- 列表用 [] 定义，数据之间使用 , 分隔
- 列表的索引从 0 开始。索引就是数据在列表中的位置编号，索引又可以被称为下标

## 类型转化

将其他序列类型转化为列表

```python
>>> s = 'hello world !'
>>> s
'hello world !'
>>> list(s)  # 使用 list() 将其他数据类型转换成列表
['h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd', ' ', '!']
```

## 列表取值

使用 arr[offset] 获取与修改元素

```python
>>> arr = ['a', 'b', 'c', 'd', 'e', 'f']
>>> arr[0]  # 直接获取
'a'
>>> arr[-1]  # 可以使用负数获取
'f'
```

根据索引位置修改内容

```python
>>> arr[0] = 'A'
>>> arr
['A', 'b', 'c', 'd', 'e', 'f']
```

## 列表切片

Python 中符合序列的有序序列都支持切片（slice），例如列表，字符串，元组。

格式：[start:stop:step]，中文就是 [起始值:结束值:步长]

- start: 起始索引，从 0 开始，-1 表示结束
- stop：结束索引
- step：步长，end-start，步长为正时，从左向右取值。步长为负时，反向取值

```python
>>> arr = list(range(10))
>>> arr
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> arr[2:5]  # 指定区间切片
[2, 3, 4]
>>> arr[2:-2]  # 可以使用负数
[2, 3, 4, 5, 6, 7]

>>> arr[0:9]  # 从头开始切片
[0, 1, 2, 3, 4, 5, 6, 7, 8]
>>> arr[0:]  # 切片到末尾
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
print(arr[0:10])
>>> arr[:]  # 省略参数切全部内容

>>> # 指定步长切片
>>> arr[0:9:1]
[0, 1, 2, 3, 4, 5, 6, 7, 8]
>>> arr[0:9:2]
[0, 2, 4, 6, 8]
#无论步长多大，起始值是会一定取到的
```

## 列表的方法

| 分类 | 关键字/函数/   | 方法说明                  |
| ---- | -------------- | ------------------------- |
| 增加 | append()       | 添加元素至尾部            |
|      | insert()       | 在指定位置插入数据        |
| 删除 | clear()        | 清空列表                  |
|      | pop()          | 默认弹出末尾数据          |
|      | pop(index)     | 弹出指定索引数据          |
|      | remove(data)   | 移除指定数据              |
| 修改 | extend(列表 2) | 将列表 2 的数据追加到列表 |
| 查询 | count(数据)    | 统计数据出现的次数        |
|      | index(内容)    | 查询内容所在位置          |
| 其他 | copy()         | 将列表复制一份            |
|      | sort()         | 排序                      |
|      | reverse()      | 逆序列表                  |

nsert、append 需要达到熟练的程度，pop / sort 用的也比较多

列表大部分的方法都是就地操作（修改原来的内容），拷贝一份进行操作（不会修改原来的值，但是会返回一个新的内容）

```python
>>> arr = ['a', 'b', 'c', 'd', 'e']
>>> arr
['a', 'b', 'c', 'd', 'e']
>>> arr.append('f')  # 添加 'f' 元素到末尾
>>> arr
['a', 'b', 'c', 'd', 'e', 'f']

>>> arr.insert(0, 'A')  # 插入'A'元素到第一个.插入是把之前位置的元素往后挤一位。
>>> arr
['A', 'a', 'b', 'c', 'd', 'e', 'f']

>>> arr.pop()  # 默认弹出最后一个元素
'f'
>>> arr
['A', 'a', 'b', 'c', 'd', 'e']

>>> arr.pop(0)  # 指定弹出第 0 个元素
'A'
>>> arr
['a', 'b', 'c', 'd', 'e']

>>> arr.remove('d')  # 指定删除内容为 'd' 的元素
>>> arr
['a', 'b', 'c', 'e']

>>> arr.index('c')  # 查询内容为 'c' 的元素在第几个位置
2

>>> arr.sort(reverse=True)  # 排序后将内容输出（默认为升序）
>>> arr
['e', 'c', 'b', 'a']
```

## 拓展元素

```python
arr1 = ['老师 1', '老师 2']
arr2 = ['老师 3', '老师 4']

# arr1.append(arr2)  # append 是追加元素，如果追加的是列表，会把整个列表放进去
>>> arr1 = ['老师 1', '老师 2']
>>> arr2 = ['老师 3', '老师 4']
>>> arr1.append(arr2)
>>> arr1
['老师 1', '老师 2', ['老师 3', '老师 4']]


# 遍历添加元素
>>> arr1 = ['老师 1', '老师 2']
>>> arr2 = ['老师 3', '老师 4']
>>> for name in arr2:
...     arr1.append(name)
...
>>> arr1
['老师 1', '老师 2', '老师 3', '老师 4']


# extend  将一个列表的元素追加到另一个列表的末尾
>>> arr1 = ['老师 1', '老师 2']
>>> arr2 = ['老师 3', '老师 4']
>>> arr1.extend(arr2)
>>> arr1
['老师 1', '老师 2', '老师 3', '老师 4']
```

## 删除元素

```python
name_list = ['正心', '全栈', '编程', '老师 1', '老师 2']

# pop 默认弹出最后一个元素（有返回值）

>>> name_list = ['正心', '全栈', '编程', '老师 1', '老师 2']
>>> item1 = name_list.pop()
>>> item2 = name_list.pop()
>>> item1, item2
('老师 2', '老师 1')


# pop(index) 可以指定索引进行弹出
>>> name_list
['正心', '全栈', '编程']
>>> item0 = name_list.pop(0)
>>> name_list
['全栈', '编程']
>>> item0
'正心'


# remove 指定内容进行删除
>>> item = name_list.remove('编程')  # remove 删除内容是没有返回值的
>>> item
>>> name_list
['全栈']
>>> name_list.remove('编程')  # 没有的内容再次删除会报错
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: list.remove(x): x not in list

# 清空列表
>>> name_list.clear()
>>> name_list
[]
```

## 修改元素

```python
name_list = ['正心', '老师 2', '老师 3']

# 修改列表元素
name_list[0] = '正心全栈编程'

print(name_list)

name_list.reverse()  # 列表逆序输出
print(name_list)

arr = [1, 5, 2, 3, 6, 8]
arr.sort(reverse=True)  # 列表排序
print(arr)

```

## 获取元素位置

```python
>>> arr = ['正心', '老师 2', '老师 3']

# index 获取元素在列表当中的位置
>>> arr.index('老师 2')
1
>>> arr[arr.index('老师 2')]
'老师 2'


# 如果元素不存在就会报错
>>> arr.index('老师 4')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: '老师 4' is not in list

# 统计元素在列表当中出现的次数
>>> arr.count('正心 1')
0

# 获取列表长度
>>> len(arr)
3
```

## 二维列表

```python
# 定义：列表是一种可变的、有序的数据容器，可以随时添加和删除其中的元素
array = [1, 2, 3, 4, 5]
array2 = [
    # [1, 2, 3, 4, 5],
    array,
    ['1', '2', '3', '4'],
    "abscdfg",
]

print(array2[1])
print(array2[1][1])

"""根据下标遍历二维列表的值"""
# 取 二维列表里面的值
# len 获取一个对象的长度
array2_len = len(array2)
print(array2_len)
for i in range(array2_len):
    # print(i)
    print(array2[i])
    # 先获取二维列表的长度
    for j in range(len(array2[i])):
        print(array2[i][j])

"""直接遍历二维列表的值"""
for row in array2:
    for col in row:
        print(col)

"""
    len 只能获取容器、序列等有长度的对象的长度
    根据下标遍历：就能去修改里面的值，可以精确的操作某一个元素
    直接遍历：只能把内容一个个遍历出来
"""
```

## 元组

定义：元组是一种不可变的序列类型
元组和列表类似，但属于不可变序列，元组一旦创建，用任何方法都不可以修改其元素。
元组的定义方式和列表相同，但定义时所有元素是放在一对圆括号“（）”中，而不是方括号中。
元组没有列表中那么多方法可以使用，因为不可变，所以安全，速度比列表快。

```python
>>> # 使用 tuple() 创建元组
>>> tuple()
()

# 使用 () 创建元组
>>> ()
()

>>> type(())
tuple
>>> type(tuple())
tuple
```

## 元组取值与切片

- 元组的取值、切片与列表时一样使用
- 不能对元组的元素进行删除，但是可以删除整个元组：

```python
>>> t = tuple("01234")
>>> t
('0', '1', '2', '3', '4')

# 直接获取
>>> t[0]
'0'
>>> t[-1]
'4'
>>> t[0:5]
('0', '1', '2', '3', '4')

# 报错 不能修改
>>> t[0] = 1
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
```

## 元组与列表的区别

- 元组一旦定义就不允许更改。
- 元组没有 append()、extend()和 insert()等方法，无法向元组中添加元素。
- 元组没有 remove()或 pop()方法，也无法对元组元素进行 del 操作，不能从元组中删除元素。
- 从效果上看，tuple( )冻结列表，而 list( )融化元组。

## 元组的优点

- 元组的速度比列表更快。如果定义了一系列常量值，而所需做的仅是对它进行遍历，那么一般使用元组而不用列表。
- 元组对不需要改变的数据进行“写保护”将使得代码 更加安全 。
- 元组可用作字典的“键”，也可以作为集合的元素。列表永远不能当做字典键使用，也不能作为集合的元素，因为列表不是不可变的。
- 不可变

## dict（字典）

定义：字典是一种可变的、无序的、键值对的、复杂的数据容器

Python 中的字典是一个键值映射的数据结构。

字典是一种可变无序数据容器，且可存储任意类型对象。 字典的每个键值 key=>value 对用冒号 : 分割， 每个键值对之间用逗号 , 分割，整个字典包括在花括号 {} 中。
字典用 {} 定义，使用键值对存储数据，键值对之间使用 , 分隔

- 键 key 是索引
- 值 value 是数据
- 键和值之间使用 : 分隔
- 键必须是唯一的
- 值可以取任何数据类型，但键只能使用字符串、数字或元组。值可以是字典。

```python
dict1 = {
    "name": "小明",
    "age": 18,
    ('s','a'): True,
    1: 1.65
}
```

## 字典常用操作

使用 字典['键'] 可以取到字典里面的内容。

```python
>>> dict1 = {
...     "name": "小明",
...     "age": 18,
...     "gender": True,
...     "height": 1.65
... }
>>> print(dict1['name'])
小明
```

使用 字典['键'] = 值 修改字典内容。

```python
>>> dict1['height'] = 0
>>> print(dict1)
{'name': '小明', 'age': 18, 'gender': True, 'height': 0}
```

当键不存在时添加内容。

```python
>>> dict1['weight'] = '60kg'
>>> print(dict1)
{'name': '小明', 'age': 18, 'gender': True, 'height': 0, 'weight': '60kg'}
```

嵌套字典取值

```python
import pprint

dict2 = {
    'name': '正心',
    'age': 18,
    'gender': True,
    'height': 1.65,
    'info': {
        'address': '中国。湖南.长沙',
        'hobby': ['吃饭', '睡觉', '写代码']
    }
}

print(dict2)
print('姓名：', dict2['name'])  # 字典是根据键取值
print('爱好：', dict2['info']['hobby'])

# 给字典的键赋值，如果键存在就会覆盖
dict2['gender'] = '男'

# 给字典的键赋值，如果键不存在，就会新增一个键值对
dict2['skill'] = ['python', 'javascript']
pprint.pprint(dict2)
```

字典常用方法

```python
clear       items       setdefault
copy        keys        update
fromkeys    pop         values
get         popitem
```

| 方法                   | 用法                                            |
| ---------------------- | ----------------------------------------------- |
| get(key, default=None) | 返回指定键的值，如果值不在字典中返回 default 值 |
| keys()                 | 以列表返回一个字典所有的键                      |
| values()               | 以列表返回字典中的所有值                        |
| update(dict2)          | 把字典 dict2 的键/值对更新到 dict 里            |
| items()                | 以列表返回可遍历的 (键，值) 元组数组            |

遍历 就是 依次 从 字典 中获取所有键值对

```pythin
# for 循环内部使用的 `key 的变量` in 字典

for k, v in dict1.items():
    print(k, v)

for k in dict1.keys():
    print(k, dict1[k])
```

## set（集合）

与数学中的集合功能一样
集合（set）是一种无序的、可变的、不可重复的数据类型。
集合用 {} 创建，一般用作于去重

```python
# 集合创建
>>> set1 = {1, 2, 2, 3, 5, 6, 4, 4}
>>> set1
{1, 2, 3, 4, 5, 6}


# 集合无需、不可重复，可以进行去重
>>> set2 = set('hello world !')
>>> set2
{'e', 'r', 'd', 'w', 'l', 'o', 'h', ' ', '!'}
```

集合方法

```python
>>> set1 = {1, 2}
>>> set1.add(3)    # list .append
>>> set1.add(10)
>>> set1
{10, 1, 2, 3}

>>> set1.update({'a', 'b', 'c'})   # list .extend
>>> set1
{'c', 1, 2, 3, 'b', 'a', 10}

>>> set1.remove('a')
>>> set1
{'c', 1, 2, 3, 'b', 10}
```

## 集合运算

```python
>>> set2 = {2, 3, 4}
>>> set3 = {3, 4, 5}
>>> print('交集：', set2 & set3)
交集: {3, 4}
>>> print('并集：', set2 | set3)
并集: {2, 3, 4, 5}
>>> print('差集：', set2 - set3)   # set2 比 set3 多出来的内容
差集: {2}
>>> print('异或集：', set2 ^ set3)  # 跟交集取反
异或集: {2, 5}
```

## 简单函数

函数：就是 封装了一段可被重复调用执行的代码块。通过此代码块可以 实现大量代码的重复使用。

函数的使用包含两个步骤：

定义函数 —— 封装独立的功能
调用函数 —— 享受封装的成果
函数的作用，在开发程序时，使用函数可以提高编写的效率以及代码的重用
<img src='/images/image.png'>

1. def ：表示函数的关键字，是英文 define 的缩写
2. 函数名：函数的名称，后续根据函数名调用函数，函数名称应该能够表达函数封装代码的功能
3. arg : 即 argument 参数
4. 函数体：函数中进行一系列的逻辑计算，如：发送邮件、计算出 [11,22,38,888,2]中的最大数等...
5. 函数名称的命名应该符合标识符的命名规则
   - 可以由 字母、下划线和数字组成
   - 不能以数字开头
   - 不能与关键字重名

```python
# 声明函数
def func():
    ...  # 函数体代码
    print()
```

def 是声明函数的关键字，必须小写，由于函数一般是为了实现某个功能才定义的，所以通常我们将函数名命名为动词，比如 get_sum

## 调用函数

```python
# 调用函数
函数名([实参列表]);  # 通过调用函数名来执行函数体代码

# 调用的时候千万不要忘记添加小括号
```

说明：

1. 函数名是当前作用域中可用的函数对象，即调用函数之前程序必须先执行 def 语句创建函数对象。

   函数的定义位置必须位于调用该函数的全局代码之前，故典型的 Python 程序结构顺序通常为 import 语句 ＞ 函数定义 ＞ 全局代码。

2. 实参列表必须与函数定义的形参列表一一对应

3. 函数调用是表达式。如果函数有返回值，可以在表达式中直接使用；如果函数没有返回值，则可以单独作为表达式语句使用。

注意：声明函数本身并不会执行代码，只有调用函数时才会执行函数体代码。

## 函数的返回值

函数是一个功能块，该功执行成功与否，需要通过返回值来告知调用者。

程序遇到的第一个 return 就会返回（退出 def 块），不会再运行第二个 return。

```python
def f(x):
    y = 5 * x + 6
    return y
    return y  # 永远无法生效


print(f(5))
```

return 之后函数就结束了，不会再执行函数内的后续代码

- 在函数体中使用 return 语句可以实现从函数中返回一个值并跳出函数的功能
- return 语句可以放置在函数中的任何位置，当执行到第一个 return 语句时程序返回到调用程序。
- 在函数体中使用 return 语句可实现从函数返回一个值并跳出函数。如果需要返回多个值，则可以返回一个元组

## 形参和实参

函数的声明可以包含一个 [形参列表]，而函数调用则通过传递 [实参列表] ，以允许函数体中的代码引用这些参数变量。声明函数时所声明的参数即为形式参数，简称形参；调用函数时提供函数所需要的参数的值即为实际参数，简称实参。实际参数值默认按位置顺序依次传递给形式参数。如果参数个数不对，将会产生错误。

```python
def my_max1(a, b):
    if a > b:
        return f'{a} > {b}'
    elif a == b:
        return f'{a} == {b}'
    else:
        return f'{a} < {b}'


x = 4
y = 5
print(my_max1(x, y))  # 4.5
print(my_max1(5, 5))  # 5.0
print(my_max1(5))  # 报错
```

声明函数时声明的形式参数等同于函数体中的局部变量，在函数体中的任何位置都可以使用。

局部变量和形式参数变量的区别在于局部变量在函数体中绑定到某个对象，而形式参数变量则绑定到函数调用代码传递的对应实际参数对象。Python 参数传递方法是传递对象引用，而不是传递对象的值。

## 传递不可变对象

在调用函数时，若传递的是不可变对象（例如 int、float、str 和 bool 对象）的引用，则如果函数体中修改对象的值，其结果实际上是创建了一个新的对象。

案例：传递不可变对象的引用示例：错误的递增函数。

```python
num = 100


def increment(arg_num, arg_n):
    arg_num += arg_n


increment(num, 10)
print(num)
```

在本例中，num 的初值为 100，当调用函数 increment(num,10) 后，在函数体内执行了 "arg_num+=10" 语句，函数体内的 arg_num 变成了 110。但是，当函数调用完毕返回主程序时 num 的值仍然为 100，因为整数 num 是不可变对象，而在 Python 语言中一个函数不能改变一个不可变对象（例如整数、浮点数、布尔值或字符串）的值（即函数无法产生副作用）。

## 传递可变对象

在调用函数时，如果传递的是可变对象（例如 list 对象）的引用，则在函数体中可以直接修改对象的值。

案例：定义一个可以交换给定列表中两个指定下标的元素值的函数。

```python
def exchange(arr, i, j):
    temp = arr[i]
    arr[i] = arr[j]
    arr[j] = temp
```

## 函数参数

### 位置参数

位置参数，在函数调用时，实参默认按位置顺序传递形参。
案例：y = k \* x +b 中 k 与 b 也不固定。

```python
def f(x, k, b):
    y = k * x + b
    print(y)


f(5, 5, 6)
```

### 关键字参数

在函数调用时，也可以通过名称（关键字）指定传入的参数，例如 my_max1(a=1，b=2) 或者 my_max1(b=2，a=1) 。

```python
def f(x, k, b):
    print("x:{} k:{} b:{}".format(x, k, b))
    y = k * x + b
    return (y)


f(x=5, k=5, b=6)
```

你也可以把位置参数和关键字参数混合起来。首先，实例化参数，然后对参数使用关键字参数的方式：

```python
def f(x, k, b):
    print("x:{} k:{} b:{}".format(x, k, b))
    y = k * x + b
    return (y)


f(5, k=5, b=6)
```

### 默认参数

当调用方没有提供对应的参数值时，你可以指定默认参数值。这个听起来很普通的特性实际上特别有用，以之前的例子为例：

```python
def f(x, k=5, b=6):
    print("x:{} k:{} b:{}".format(x, k, b))
    y = k * x + b
    return y


f(5)
f(x=5)
f(x=5, k=5)
f(x=5, k=5, b=6)
```

### \*args

收集位置参数
在不清楚传入参数是多少个

```python
# 用 * 收集位置参数
# int * 特殊符号 有特殊的作用，在定义函数的括号里面，用于收集所有的位置参数
# 在输出 或者是运行代码的过程中 是解包 包：元组、列表、迭代器、生成器
def print_args(*args):
    # * 解包的标志
    print('位置参数的类型：', type(args))
    print('位置参数的内容：', args)
```

无参数调用函数，则什么也不会返回：

```python
>>> def print_args(*args):
...     # * 解包的标志
...     print('位置参数的类型：', type(args))
...     print('位置参数的内容：', args)
...
>>> print_args()
位置参数的类型: <class 'tuple'>
位置参数的内容: ()
```

给函数传入的所有参数都会以元组的形式返回输出：

```python
>>> print_args(3, 2, 1, 'wait!', 'uh...')
位置参数的类型: <class 'tuple'>
位置参数的内容: (3, 2, 1, 'wait!', 'uh...')
```

### \*\*kwargs

收集关键字参数
使用两个星号可以将参数收集到一个字典中，参数的名字是字典的键，对应参数的值是字典的值。下面的例子定义了函数 print_kwargs() ，然后打印输出它的关键字参数：

```python
def print_kwargs(*arg, **kwargs):
    """ args 为关键字元组  kwargs 为双元关键字元组 """
    print('位置参数：', arg)
    print('关键字参数：', kwargs)

print_kwargs(0,20,name=23)# 使用 参数名=值 的方式传输。直接传递值会被位置参数吸收
>>>位置参数： (0, 20)
>>>关键字参数： {'name': 23}
```

## 变量的作用域

变量声明的位置不同，其可以被访问的范围也不同。变量的可被访问范围称为变量的作用域。变量按其作用域大致可以分为全局变量、局部变量和类成员变量。

## 全局变量

在一个源代码文件中，在函数和类定义之外声明的变量称为全局变量。全局变量的作用域为其定义的模块，从定义的位置起，直到文件结束位置。

通过 import 语句导入模块，也可以通过全限定名称“模块名。变量名”访问；或者通过 from … import 语句导入模块中的变量并访问。

不同的模块都可以访问全局变量，这会导致全局变量的不可预知性。如果多个语句同时修改一个全局变量，则可能导致程序产生错误，且很难发现和更正。

全局变量降低了函数或模块之间的通用性，也降低了代码的可读性。在一般情况下，应该尽量避免使用全局变量。全局变量一般作为常量使用。

```python
TAX1 = 0.17  # 税费常量 17 %
TAX2 = 0.2  # 税费常量 20 %
TAX3 = 0.05  # 税费常量 5 %
PI = 3.14  # 圆周率
```

## 局部变量

在函数体中声明的变量（包括函数参数）称为局部变量，其有效范围（作用域）为函数体。

全局代码不能引用一个函数的局部变量或形式参数变量；一个函数也不能引用在另一个函数中定义的局部变量或形式参数变量。如果在一个函数中定义的局部变量（或形式参数变量）与全局变量重名，则局部变量（或形式参数变量）优先，即函数中定义的变量是指局部变量（或形式参数变量），而不是全局变量。

```python
num = 100


def func():
    num = 15
    return num


print(func())
print(num)
```

说明：函数 f() 中的 print(num) 语句引用的是局部变量 num，因此输出 105。

如果要为定义在函数外的全局变量赋值，可以使用 global 语句，表明变量是在外面定义的全局变量。global 语句可以指定多个全局变量，例如 global x, y, z 。一般应该尽量避免这样使用全局变量，全局变量会导致程序的可读性差。

```python
pi = 3.141592653589793
e = 2.718281828459045


def my_func():
    global pi
    pi = 3.14
    print('global pi = ', pi)
    e = 2.718
    print('local e = ', e)


print('module pi = ', pi)
print('module e = ', e)
my_func()
print('module pi = ', pi)
print('module e = ', e)
```

## 递归函数

递归函数即自调用函数，在函数体内部直接或间接地自己调用自己，即函数的嵌套调用是函数本身。递归函数常用来实现数值计算的方法。

## 递归函数的原理

递归提供了建立数学模型的一种直接方法，与数学上的数学归纳法相对应。

每个递归函数必须包括以下两个主要部分。

（1）终止条件：表示递归的结束条件，用于返回函数值，不再递归调用。例如，factorial()函数的结束条件为“n 等于 1”。

（2）递归步骤：递归步骤把第 n 步的参数值的函数与第 n-1 步的参数值的函数关联。例如，对于 factorial() ，其递归步骤为 n\*factorial（n-1） 。另外，一序列的参数值必须逐渐收敛到结束条件。例如，对于 factorial()，每次递归调用参数值 n 均递减 1，所以一序列参数值逐渐收敛到结束条件（n=1）。例如，调和数的计算公式如下。

故可以使用递归函数实现。

（1）终止条件：
当 n==1 时

（2）递归步骤：
当 n ＞ 1 时

每次递归，n 故逐渐收敛于 1。

## 类与对象

类型（汉语词语），指包含由各特殊的事物或现象抽出来的共通点的抽象概念；

类（Class）是面向对象程序设计（OOP，Object-Oriented Programming）实现信息封装的基础。

## 面向对象

面向对象编程 —— Object Oriented Programming 简写 OOP

对象到底是什么，我们可以从两次层次来理解。

(1) 对象是单个事物的抽象

一本书、一辆汽车、一个人都可以是对象，一个数据库、一张网页、一个与远程服务器的连接也可以是对象。当实物被抽象成对象，实物之间的关系就变成了对象之间的关系，从而就可以模拟现实情况，针对对象进行编程。

例如，一个“人”对象可以表示具有姓名，年龄，身高、体重等属性，具有吃饭，睡觉，呼吸和跑步等行为。

换句话说，面向对象编程是将现实世界的事物在程序中建立模型的关系方法，如现实世界地形与导航软件中的地形，现实世界中购物常见与电商软件的购物场景，现实世界中的看房与网站上的在线看房。

(2) 对象是一个容器，封装了属性（property）和方法（method）

属性是对象的状态，方法是对象的行为（完成某种任务）。

比如，我们可以把动物抽象为 Animal 类，使用“属性”记录具体是那一种动物，使用“方法”表示动物的某种行为（奔跑、捕猎、休息等等）。

在实际开发中，对象是一个抽象的概念，可以将其简单理解为：数据集或功能集。

提示：每个对象都是基于一个引用类型创建的，这些类型可以是系统内置的原生类型，也可以是开发人员自定义的类型。

1. 对象是什么？

- 对象 = 属性 + 行为

- 对象是现实世界实体的数字化表示

- 每个对象包含：

  - 状态（属性/数据）：描述对象的特征

  - 行为（方法/函数）：描述对象能做什么-

我的理解就是将现实生活中的事物传进计算机，现实中的数据被分为了属性和行为。类型有很多，上面说的在网页上面看房子，这是一个抽象的过程，现实生活中也有这样的抽象的过程，比如给事物命名，对一个现在或过去的事情进行描述，都是这样，对象是把现实生活中或者是自己所构想的在计算机里建立起来。

<iframe src="https://docs.zhengxinonly.com/01_base/py_01_base/06_object/01_intro.html" frameborder="0" width=100% height=444></iframe>

## 类和对象的概念

- 类 和 对象 是面向对象编程的两个核心概念

- 类 是对一群具有相同 特征 或者 行为 的事物的一个统称，是抽象的。

- 特征 被称为 属性
  行为 被称为 方法

## 类和对象的关系

- 类 是模板，对象 是根据 类 这个模板创建出来的，应该先有类，再有对象
- 类 只有一个，而 对象 可以有很多个
- 不同的对象 之间 属性 可能会各不相同
- 类 中定义了什么 属性和方法，对象 中就有什么属性和方法

创建类需要先进行初始化，然后创建属性跟方法。在使用时传入参数即可

```python
"""
定义一个人（Person）类
    人在出生时就会有名字、身高、体重等特征
    人在刚出生是会吃、喝、哭等行为
"""
class Person(object):

    def __init__(self, name, age):
        # 在方法内部通过 self 访问实例属性，而不是直接使用变量名，第一个参数必须是self（约定俗成）
        """初始化方法"""
        self.name = name # 给这个类添加属性

        self.age = age # 给这个类添加属性

    # 给类添加方法
    def hello(self):
        print('我的名字是：{}，已经：{}岁了'.format(self.name, self.age))


zx = Person('正心', 18)
# 获取属性
print(zx.name)
print(zx.age)

# 在外部修改属性
zx.age = 18

# 再外部新增属性
zx.gender = '男'

# 调用方法
zx.hello()
#  输出：我的名字是：正心，已经：18岁了
```

